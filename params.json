{"name":"VMMC","tagline":"A C++ library to implement the \"virtual-move\" Monte Carlo algorithm for approximating the dynamical evolution of systems of strongly interacting overdamped particles.","body":"# LibVMMC\r\n\r\nCopyright &copy; 2015 Lester Hedges.\r\n\r\nReleased under the [GPL](http://www.gnu.org/copyleft/gpl.html).\r\n\r\n## About\r\nA simple C++ library to implement the \"virtual-move\" Monte Carlo (VMMC)\r\nalgorithm of [Steve Whitelam](http://nanotheory.lbl.gov/people/SteveWhitelam.html)\r\nand [Phill Geissler](http://www.cchem.berkeley.edu/plggrp/index.html), see:\r\n\r\n* Avoiding unphysical kinetic traps in Monte Carlo simulations of strongly\r\nattractive particles, S. Whitelam and P.L. Geissler,\r\n[Journal of Chemical Physics, 127, 154101 (2007)](http://dx.doi.org/10.1063/1.2790421)\r\n\r\n> We introduce a “virtual-move” Monte Carlo algorithm for systems of\r\n> pairwise-interacting particles. This algorithm facilitates the simulation\r\n> of particles possessing attractions of short range and arbitrary strength\r\n> and geometry, an important realization being self-assembling particles\r\n> endowed with strong, short-ranged, and angularly specific (“patchy”)\r\n> attractions. Standard Monte Carlo techniques employ sequential updates\r\n> of particles and can suffer from low acceptance rates when attractions are\r\n> strong. In this event, collective motion can be strongly suppressed. Our\r\n> algorithm avoids this problem by proposing simultaneous moves of collections\r\n> (clusters) of particles according to gradients of interaction energies.\r\n> One particle first executes a “virtual” trial move. We determine which of\r\n> its neighbors move in a similar fashion by calculating individual bond\r\n> energies before and after the proposed move. We iterate this procedure and\r\n> update simultaneously the positions of all affected particles. Particles\r\n> move according to an approximation of realistic dynamics without requiring\r\n> the explicit computation of forces and without the step size restrictions\r\n> required when integrating equations of motion. We employ a size- and\r\n> shape-dependent damping of cluster movements, motivated by collective\r\n> hydrodynamic effects neglected in simple implementations of Brownian dynamics.\r\n\r\n* Approximating the dynamical evolution of systems of strongly interacting\r\noverdamped particles, S. Whitelam,\r\n[Molecular Simulation, 37 (7) (2011)](http://dx.doi.org/10.1080/08927022.2011.565758).\r\n(Preprint version available [here](http://arxiv.org/abs/1009.2008).)\r\n\r\nOur primary goal is to make VMMC accessible to a wider audience, for whom the\r\ntime required to code the algorithm poses a significant barrier to using the\r\nmethod. This allows the user to focus on model development.\r\n\r\nThe animation below shows a comparison of the dynamics generated by traditional\r\nsingle-particle Monte Carlo (SPMC) and the VMMC algorithm for a periodic\r\ntwo-dimensional [square-well fluid](http://www.sklogwiki.org/SklogWiki/index.php/Square_well_model).\r\nThe model system consists of particles interacting via strong, short-ranged\r\nisotropic interactions. Due to the suppression of collective particle\r\nrearrangements, SPMC results in the slow [Ostwald ripening](https://en.wikipedia.org/wiki/Ostwald_ripening)\r\nof isolated clusters. In contrast, VMMC facilitates the diffusion and\r\ncoalescence of particle clusters, resulting in a long-time dynamics that\r\nis dominated by the motion of a single large cluster. Both trajectories\r\nrepresent one billion trial moves of the respective algorithms, with the system\r\ninitialised with a random, non-overlapping, particle configuration in each case.\r\n\r\n![Comparison of the single particle and virtual-move Monte Carlo algorithms.](https://raw.githubusercontent.com/lohedges/assets/master/vmmc/animations/comparison.gif)\r\n\r\nThe VMMC algorithm works by proposing the move of a single, randomly chosen,\r\n\"seed\" particle. If, following the move, the change in the energy of interaction\r\nbetween the particle and its neighbours is unfavourable, then those neighbours\r\nare recruited and moved in concert. This process is iterated recursively for\r\neach new recruit until no further particles show a tendency to move.\r\n\r\nThe animations below illustrate example VMMC translation and rotation moves\r\ntaken from a real simulation. Red indicates the most recent recruit to the\r\ncluster, orange indicates the nearest neigbour to which link formation is\r\ncurrently being tested, and green indicates those particles that have been\r\naccepted as part of the cluster move. The animations show how a recursive\r\ndepth-first search is used to iteratively link particles to the cluster.\r\nParticles are linked according to probabilities based on the pair interaction\r\nenergy differences following the forward and reverse virtual move of each\r\nrecruit. Computation of the reverse move is required to enforce superdetailed\r\nbalance, thus ensuring that the probability of a given particle pushing or\r\npulling on the cluster is the same.\r\n\r\n<section>\r\n    <img width=\"310\" src=\"https://raw.githubusercontent.com/lohedges/assets/master/vmmc/animations/translation.gif\">\r\n    <img width=\"310\" src=\"https://raw.githubusercontent.com/lohedges/assets/master/vmmc/animations/rotation.gif\">\r\n</section>\r\n\r\n## Installation\r\nA `Makefile` is included for building and installing LibVMMC.\r\n\r\nTo compile LibVMMC, then install the library, documentation, and demos:\r\n\r\n```bash\r\n$ make build\r\n$ make install\r\n```\r\n\r\nBy default, the library installs to `/usr/local`. Therefore, you may need admin\r\npriveleges for the final `make install` step above. An alternative is to change\r\nthe install location:\r\n\r\n```bash\r\n$ PREFIX=MY_INSTALL_DIR make install\r\n```\r\n\r\nFurther details on using the Makefile can be found by running make without\r\na target, i.e.\r\n\r\n```bash\r\n$ make\r\n```\r\n\r\n## Compiling and linking\r\nTo use LibVMMC with a C/C++ code first include the LibVMMC header file somewhere\r\nin the code.\r\n\r\n```cpp\r\n//example.cpp\r\n#include <vmmc/VMMC.h>\r\n```\r\n\r\nThen to compile, we can use something like the following:\r\n\r\n```bash\r\n$ g++ -std=c++11 example.cpp -lvmmc\r\n```\r\n\r\nThis assumes that we have used the default install location `/usr/local`. If\r\nwe specify an install location, we would use a command more like the following:\r\n\r\n```bash\r\n$ g++ -std=c++11 example.cpp -I/my/path/include -L/my/path/lib -lvmmc\r\n```\r\n\r\nNote that the `-std=c++11` compiler flag is needed for `std::function` and\r\n`std::random`.\r\n\r\n## Dependencies\r\nLibVMMC uses the [Mersenne Twister](http://en.wikipedia.org/wiki/Mersenne_Twister)\r\npsuedorandom number generator. A C++11 implementation using `std::random` is\r\nincluded as a bundled header file, `MersenneTwister.h`. See the source code or\r\ngenerate Doxygen documentation with `make doc` for details on how to use it.\r\n\r\n## Callback functions\r\nLibVMMC works via four user-defined callback functions that abstract model\r\nspecific details, such as the pair potential. We make use of C++11's\r\n`std::function` to provide a general-purpose function wrapper, i.e.\r\nthe callbacks can be free functions, member functions, etc. These callbacks\r\nallow LibVMMC to be blind to the implementation of the model, as well as\r\nthe model to be blind to the details of the VMMC algorithm. The generic\r\nnature of the function wrapper provides great flexibility to the user, freeing\r\nthem from a specific design choice for the model in hand. It is possible to\r\nglue together components written in different ways, or to use the callbacks\r\nthemselves as C/C++ wrappers to external libraries.\r\n\r\nAn alternative version of LibVMMC that shows how to achieve the same callback\r\nfunctionality using a pure abstract `Model` base class can be found in the\r\n`pure-abstract` branch. While this provides a cleaner interface, the additional\r\nflexibility provided by `std::function` more than offsets the minimal\r\nperformance cost.\r\n\r\nDetails of the callback prototypes are given below (where `typedef` has\r\nbeen used to simplify their declaration).\r\n\r\n### Particle energy\r\nCalculate the total pair interaction energy felt by a particle.\r\n```cpp\r\ntypedef std::function<double (unsigned int index, double position[],\r\n    double orientation[])> EnergyCallback;\r\n```\r\n`index` = The particle index.\r\n\r\n`position` = An x, y, z (or x, y in 2D) coordinate vector for the particle.\r\n\r\n`orientation` = The particle's orientation unit vector.\r\n\r\nThis callback function is currently somewhat redundant since it is possible to\r\nachieve the same outcome by combining the `PairEnergyCallback` and\r\n`InteractionsCallback` functions described below. Ultimately, the callback\r\nwill be able to account for non-pairwise terms in the potential, such as\r\nan external field.\r\n\r\n### Pair energy\r\nCalculate the pair interaction between two particles.\r\n```cpp\r\ntypedef std::function<double (unsigned int index1, double position1[],\r\n    double orientation1[], unsigned int index2, double position2[],\r\n    double orientation2[])> PairEnergyCallback;\r\n```\r\n`index1` = The index of the first particle.\r\n\r\n`position1` = The coordinate vector of the first particle.\r\n\r\n`orientation1` = The orientation unit vector of the first particle.\r\n\r\n`index2` = The index of the second particle.\r\n\r\n`position2` = The coordinate vector of the second particle.\r\n\r\n`orientation2` = The orientation unit vector of the second particle.\r\n\r\n### Interactions\r\nDetermine the interactions for a given particle.\r\n```cpp\r\ntypedef std::function<unsigned int (unsigned int index, double position[],\r\n    double orientation[], unsigned int interactions[])> InteractionsCallback;\r\n```\r\n`index` = The index of the  particle.\r\n\r\n`position` = The coordinate vector of the particle.\r\n\r\n`orientation` = The orientation unit vector of the particle.\r\n\r\n`interactions` = An array to store the indices of the interactions.\r\n\r\n### Post-move\r\nApply any post-move updates, e.g. update cell lists, or neighbour lists.\r\n```cpp\r\ntypedef std::function<void (unsigned int index, double position[],\r\n    double orientation[])> PostMoveCallback;\r\n```\r\n`index` = The index of the  particle.\r\n\r\n`position` = The coordinate vector of the particle following the move.\r\n\r\n`orientation` = The orientation unit vector of the particle following the move.\r\n\r\n## Assigning a callback\r\nUsing the callbacks above it is easy to create a function wrapper to whatever,\r\ne.g.\r\n\r\n```cpp\r\nvmmc::EnergyCallback energyCallback = computeEnergy;\r\n```\r\n\r\nif `energyCallback` were a free function, or\r\n\r\n```cpp\r\nFoo foo;\r\nusing namespace std::placeholders;\r\nvmmc::EnergyCallback energyCallback = std::bind(&Foo::computeEnergy, foo, _1, _2, _3);\r\n```\r\n\r\nif `energyCallback` were instead a member of some object called `Foo`.\r\n\r\n## The VMMC object\r\nTo use LibVMMC you will want to create an instance of the VMMC object. This has the following\r\nconstructor:\r\n```cpp\r\nVMMC(unsigned int nParticles, unsigned int dimension, double coordinates[],\r\n    double orientations[], double maxTrialTranslation, double maxTrialRotation,\r\n    double probTranslate, double referenceRadius, unsigned int maxInteractions,\r\n    double boxSize[], bool isIsotropic[], bool isRepulsive,\r\n    const EnergyCallback& energyCallback, const PairEnergyCallback&\r\n    pairEnergyCallback, const InteractionsCallback& interactionsCallback,\r\n    const PostMoveCallback& postMoveCallback);\r\n```\r\n`nParticles` = The number of particles in the simulation box.\r\n\r\n`dimension` = The dimension of the simulation box (either 2 or 3).\r\n\r\n`coordinates` = An array containing coordinates for all of the particles in the\r\nsystem, i.e. `x1, y1, z1, x2, y2, z2, ... , xN, yN, zN.`\r\nCoordinates should run from 0 to the box size in each dimension.\r\n\r\n`orientations` = An array containing orientations (unit vectors) for all of the\r\nparticles in the system, i.e. `nx1, ny1, nz1, nx2, ny2, nz2, ... , nxN, nyN, nzN.`\r\nIn the case of particles interacting via an isotropic potential, the particle\r\norientations are entirely redundant, i.e. the orientation has no effect on the\r\npotential. This allows the use of a single set of callback functions for models\r\nwith both isotropic and anisotropic potentials.\r\n\r\n`maxTrialTranslation` = The maximum trial translation, in units of the particle\r\ndiameter (or typical particle size).\r\n\r\n`maxTrialRotation` = The maximum trial rotation in radians.\r\n\r\n`probTranslate` = The probability of attempting a translation move (relative to rotations).\r\nAlong with `maxTrialTranslation` and `maxTrialRotation`, `probTranslate` can be tuned to\r\nenforce an approximate Stokes drag. An excellent and detailed explanation of how this may\r\nbe applied in practice can be found\r\n[here](http://nanotheory.lbl.gov/people/design_rules_paper/methods.pdf).\r\n\r\n`referenceRadius` = A reference radius for computing the approximate hydrodynamic\r\ndamping factor, e.g. the radius of a typical particle in the system.\r\n\r\n`maxInteractions` = The maximum number of pair interactions that an individual\r\nparticle can make. This will be used to resize LibVMMC's internal data\r\nstructures and the user should assert that this limit isn't exceed in the\r\n`InteractionsCallback` function. The number can be chosen from the symmetry\r\nof the system, e.g. if particles can only make a certain number of patchy\r\ninteractions, or by estimating the average number of neighbours within the\r\ninteraction volume around a particle.\r\n\r\n`boxSize` = The base length of the simulation box in each dimension.\r\n\r\n`isIsotropic` = Whether the potential of each particle is isotropic. The\r\nhandling of rotational moves is slightly different for moves seeded from\r\nisotropic particles, e.g. spheres, since the rotation of the seed causes\r\nno change in energy. This boolean array allows LibVMMC to handle\r\nmixed-potential systems.\r\n\r\n`isRepulsive` = Whether the potential has finite energy repulsions. This should\r\nalso be set to `true` when particle interactions contain a mixture of hard core\r\noverlaps and finite repulsions.\r\n\r\n`energyCallback` = The callback function to calculate the total pair interaction\r\nfor a particle.\r\n\r\n`pairEnergyCallback` = The callback function to calculate the pair interaction\r\nbetween two particles.\r\n\r\n`interactionsCallback` = The callback function to determine the neighbours with\r\nwhich a particle interacts.\r\n\r\n`postMoveCallback` = The callback function to perform any required updates\r\nfollowing the move. Here you should copy the updated particle positions and\r\norientations back into your own data structures and implement any additional\r\nupdates, e.g. cell lists.\r\n\r\n## C-style arrays\r\nThe VMMC object constructor and callback functions use C-style arrays as\r\narguments for simplicity and generality. This (hopefully) makes it as easy\r\nas possible for a user unfamiliar with C++ to make use of LibVMMC (although\r\neveryone should take time to learn `std::vector`). We can also exploit the\r\nfact that the C++ standard imposes that `std::vector` elements are contiguous,\r\nwhich allows `std::vector` containers to be passed as naked arrays.\r\n\r\nFor example, if we have some function called `foo` that accepts a C-style\r\ndouble array as an argument,\r\n\r\n```cpp\r\nvoid foo(double arr[]);\r\n```\r\n\r\nthen both of the following are valid function calls\r\n\r\n```cpp\r\n// C style\r\ndouble c_arr[10];\r\nfoo(c_arr);\r\n\r\n// C++ style\r\nstd::vector<double> cpp_arr(10);\r\nfoo(&cpp_arr[0]);\r\n```\r\nInternally, LibVMMC uses `std::vector` containers for its data structures, with\r\ndata passed to the callback functions in the manner described above.\r\n\r\n## Executing a virtual move\r\nOnce an instance of the VMMC object is created, e.g.\r\n```cpp\r\nVMMC(...) vmmc;\r\n```\r\nthen a single trial move can be executed as follows:\r\n```cpp\r\nvmmc.step();\r\n```\r\nTo perform 1000 trial moves:\r\n```cpp\r\nvmmc.step(1000);\r\n```\r\nThe same can be achieved by using the overloaded `++` and `+=` operators,\r\ni.e. `vmmc++` for a single step, and `vmmc += 1000` for 1000 steps.\r\n\r\n## Demos\r\nThe following example codes showing how to interface with LibVMMC are included\r\nin the `demos` directory.\r\n\r\n* `square_wellium.cpp`: A simulation of a square-well fluid in two- or three-dimensions.\r\n* `lennard_jonesium.cpp`: A simulation of a Lennard-Jones fluid in two- or three-dimensions.\r\n* `patchy_disc.cpp`: A simulation of a two dimensional patchy disc model.\r\n\r\nWhen run, each of the demos output a trajectory file, `trajectory.xyz`, and a\r\nTcL script, `vmd.tcl`, that can be used to set camera and particle attributes\r\nand to draw the periodic simulation box when visualising the trajectory with\r\n[VMD](http://www.ks.uiuc.edu/Research/vmd/). To generate and view a trajectory,\r\nrun, e.g.\r\n\r\n```bash\r\n$ ./demos/square_wellium\r\n$ vmd trajectory.xyz -e vmd.tcl\r\n```\r\n\r\nThe demo code also illustrates how to implement efficient, dynamically\r\nupdated cell lists. See `demos/src/CellList.h` and `demos/src/CellList.cpp`\r\nfor implementation details.\r\n\r\n## Tests\r\nA full test suite is forthcoming. This will allow a detailed comparison between\r\nVMMC and standard single-move Monte Carlo (SPMC) for various model systems at a\r\nrange of state points.\r\n\r\nShown below are time-averaged pair distribution functions for Lennard-Jonesium\r\nand the square-well fluid taken from configurations equilibrated using the demo\r\ncodes outlined above (although run for 10 times as long). In both cases the\r\nequilibrated structures are indistinguishable from those generated by SPMC.\r\nNote that the pair distribution functions don't converge to one at large\r\nparticle separations since we are not considering a bulk system, rather a\r\nfinite cluster in a background vapour. See the demos codes\r\n`demos/lennard_jonesium.cpp` and `demos/square_wellium.cpp` for details\r\nof the interaction parameters (Lennard-Jonesium is sampled in the liquid\r\nphase, the square-well fluid is sampled in the crystal (FCC/HCP) phase).\r\n\r\n![Comparison of pair distribution functions for configurations equilibrated with SPMC and VMMC.](https://raw.githubusercontent.com/lohedges/assets/master/vmmc/images/pair-distribution.png)\r\n\r\n## Defining a model\r\nThe demo code illustrates a simple way of defining and handling different model\r\npotentials. A base class, `Model`, is used to declare default functionality and\r\ncallbacks. Derived classes, such as `LennardJonesium`, are used to implement the\r\nmodel specific pair potential, which is declared as a virtual method in the base\r\nclass.\r\n\r\nDeclaring a new user-defined model should be as easy as creating a `UserModel`\r\nclass with public inheritance from the `Model` base class, then overriding\r\nthe virtual `computePairEnergy` method. The `LennardJonesium`, `SquareWellium`,\r\nand `PatchyDisc` classes will serve as useful templates.\r\n\r\n## Pure isotropic systems\r\nThe default build of LibVMMC provides support for systems of isotropic and\r\nanisotropic particles, or mixtures of both. However, in the case of pure\r\nisotropic systems, e.g. spherical particles interacting via a spherically\r\nsymmetric potential, such as the square-well fluid, particle orientations\r\nare entirely redundant since they have no bearing on the potential. This\r\nmeans that there is no need to pass orientations as arguments to callback\r\nfunctions, or to update particle orientations during VMMC trial moves.\r\n\r\nWe provide preprocessor directives that allow LibVMMC to be compiled as an\r\noptimised library for pure isotropic systems. This can be achieved as follows:\r\n\r\n```bash\r\n$ OPTFLAGS=-DISOTROPIC make build\r\n```\r\n\r\nThe isotropic version of LibVMMC provides a simplified set of callback\r\nfunctions that require no particle orientations. For example, the\r\n`PairEnergyCallback` becomes\r\n\r\n```cpp\r\ntypedef std::function<double (unsigned int index1, double position1[],\r\n    unsigned int index2, double position2[])> pairEnergyCallback;\r\n```\r\n\r\nIn addition, the VMMC object no longer needs the `orientations` or\r\n`isIsotropic` arrays to be passed to its constructor, which is simplified to\r\n\r\n```cpp\r\nVMMC(unsigned int nParticles, unsigned int dimension, double coordinates[],\r\n    double maxTrialTranslation, double maxTrialRotation, double probTranslate,\r\n    double referenceRadius, unsigned int maxInteractions, double boxSize[],\r\n    bool isRepulsive, const energyCallback& energyCallback,\r\n    const pairEnergyCallback& pairEnergyCallback,\r\n    const interactionsCallback& interactionsCallback,\r\n    const postMoveCallback& postMoveCallback);\r\n```\r\n\r\nThe demo code shows how preprocessor directives can be used to provide support\r\nfor either version of the library, e.g. for the default `computeEnergy` callback\r\ndefined in the `Model` class, we have\r\n\r\n```cpp\r\n#ifndef ISOTROPIC\r\n    virtual double computeEnergy(unsigned int, double[], double[]);\r\n#else\r\n    virtual double computeEnergy(unsigned int, double[]);\r\n#endif\r\n```\r\n\r\nThe pure isotropic version of LibVMMC can provide a significant performance\r\ngain when executing rotations of large clusters in isotropic systems.\r\n\r\nNote that the demo `patchy_disc.cpp` will not compile against the isotropic\r\nversion of the library since the model is anisotropic and requires that\r\nparticle orientations are passed to its callback functions.\r\n\r\n## Limitations\r\n* The calculation of the hydrodynamic damping factor assumes a spherical cluster,\r\nwhich is only approximate in two dimensions. In general, it is likely that\r\nparticles on a flat surface may diffuse in a system-specific way, so there may\r\nbe no good general approximation of Stokes scaling in two dimensions. In future\r\nversions we intend to provide an additional callback function so that the user can\r\nenforce a model-specific damping factor.\r\n* The recursive manner in which the trial cluster is built can lead to a stack\r\noverflow if the cluster contains many particles. Typically, thousands, or tens\r\nof thousands of particles should be perfectly manageable. The typical memory\r\nfootprint for a simulation of 1000 particles is around 2.5MB for hard particles.\r\nThis is roughly doubled if the potential has finite energy repulsions.\r\n\r\n## Efficiency\r\nIn aid of generality there are several sources of redundancy that impact the\r\nefficiency of the VMMC implementation. As written, LibVMMC performs around 3-4\r\ntimes worse than a fully optimised VMMC code for square-well fluids. A few\r\nefficiency considerations are listed below in case the user wishes to modify\r\nthe VMMC source code in order to improve performance.\r\n\r\n* When calculating a list of neighbours with which a given particle interacts\r\nit's likely that you'll need to calculate the pair interaction energy. For\r\ncertain models it may be more efficient to return a list of pair energies\r\nalong with the interactions, rather than having to recalculate them.\r\n* For models with an isotropic interaction of fixed energy scale the pair\r\nenergy is simply a constant. As such, the pair energy calculation is entirely\r\nredundant, i.e. knowing that two particles interact is enough to know the\r\npair energy.\r\n* If using cell lists, the typical size of a trial displacement will be small\r\nenough such that a particle stays within the same neighbourhood of cells\r\nfollowing the trial move. (This isn't necessarily true for rotation moves,\r\nwhere the displacement of particles far from the rotation axis can be large.)\r\nAs such, there is often no need to update cell lists until confirming that\r\nthe post-move configuration is valid, e.g. no overlaps. At present the same\r\n`PostMoveCallback` function is called twice: once in order to apply the move;\r\nagain if the move is subsequently rejected. This means that the cell lists\r\nwill be updated twice if a move is rejected.\r\n* When testing for particle overlaps following a virtual move it is normally\r\nnot necessary to test pairs within the moving cluster. As written, all links\r\nare tested, not just those external to the cluster. Note that *all* internal\r\npairs should be tested following a rotational move since it's possible to\r\nrotate a cluster on top of itself. This can occur in a dense system when one\r\naxis of a cluster is longer than the box size, e.g. the cluster lies diagonally\r\nin a square box. In this case, a rotation across the periodic boundary can cause\r\nthe cluster to overlap.\r\n* Due to the overhead of binding member functions it is marginally faster to use\r\nfree functions as callbacks.\r\n\r\n## Tips\r\n* LibVMMC currently assumes that the simulation box is periodic in all dimensions.\r\nTo impose non-periodic boundaries simply check whether the move leads to a particle\r\nbeing displaced by more than half the box width along the restricted dimension and\r\nreturn an appropriately large energy so that the move will be rejected.\r\n* It is not a requirement that all particles in the simulation box be of the same\r\ntype. Make use of the particle indices that are passed to callback functions in\r\norder to distinguish different species.\r\n* The use of `std::function` allows the user to wrap arbitary functions as callbacks\r\n(rather than only using free functions, as with C-style function pointers). See\r\n[here](http://en.cppreference.com/w/cpp/utility/functional/function) for details\r\non how to bind member functions, or function objects.\r\n\r\n## Disclaimer\r\nPlease be aware that this a working repository so the code should be used at\r\nyour own risk. At present the code is being tested so expect that it will be\r\nupdated fairly frequently with additional features and performance enhancements.\r\n\r\nIt would be great to hear from you if this code was of use in your research.\r\n\r\nEmail bugs, comments, and suggestions to lester.hedges+vmmc@gmail.com.\r\n","google":"UA-38348443-2","note":"Don't delete this file! It's used internally to help with page regeneration."}